# -*- coding: utf-8 -*-
#-----------------------------------------------------------------------------
# (C) British Crown Copyright 2012-4 Met Office.
#
# This file is part of Rose, a framework for meteorological suites.
#
# Rose is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Rose is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Rose. If not, see <http://www.gnu.org/licenses/>.
#-----------------------------------------------------------------------------
"""Builtin application: rose_prune: suite housekeeping application."""

import os
from rose.app_run import BuiltinApp, ConfigValueError
from rose.date import RoseDateTimeOperator
from rose.env import env_var_process, UnboundEnvironmentVariableError
from rose.fs_util import FileSystemEvent
from rose.popen import RosePopenError
import shlex

class RosePruneApp(BuiltinApp):

    """Prune files and directories generated by suite tasks."""

    SCHEME = "rose_prune"
    SECTION = "prune"

    def run(self, app_runner, conf_tree, *_):
        """Suite housekeeping application.

        This application is designed to work under "rose task-run" in a cycling
        suite.

        """
        suite_name = os.getenv("ROSE_SUITE_NAME")
        if not suite_name:
            return
        prune_remote_logs_cycles = self._get_conf(conf_tree,
                                                  "prune-remote-logs-at")
        archive_logs_cycles = self._get_conf(conf_tree, "archive-logs-at")
        if prune_remote_logs_cycles or archive_logs_cycles:
            tmp_prune_remote_logs_cycles = []
            for cycle in prune_remote_logs_cycles:
                if cycle not in archive_logs_cycles:
                    tmp_prune_remote_logs_cycles.append(cycle)
            prune_remote_logs_cycles = tmp_prune_remote_logs_cycles
            if prune_remote_logs_cycles:
                app_runner.suite_engine_proc.job_logs_pull_remote(
                            suite_name, prune_remote_logs_cycles,
                            prune_remote_mode=True)
            if archive_logs_cycles:
                app_runner.suite_engine_proc.job_logs_archive(
                            suite_name, archive_logs_cycles)
        globs = []
        suite_engine_proc = app_runner.suite_engine_proc
        for key, max_args in [("datac", 1), ("work", 2)]:
            for cycle, cycle_args in self._get_conf(conf_tree,
                                                    "prune-" + key + "-at",
                                                    max_args=max_args):
                tail_globs = None
                if cycle_args:
                    tail_globs = shlex.split(cycle_args.pop())
                head_globs = None
                if cycle_args:
                    head_globs = shlex.split(cycle_args.pop())
                for head in suite_engine_proc.get_cycle_items_globs(
                                                    key, cycle, head_globs):
                    if tail_globs:
                        for tail_glob in tail_globs:
                            globs.append(os.path.join(head, tail_glob))
                    else:
                        globs.append(head)
        hosts = suite_engine_proc.get_suite_jobs_auths(suite_name)
        suite_dir_rel = suite_engine_proc.get_suite_dir_rel(suite_name)
        form_dict = {"d": suite_dir_rel, "g": " ".join(globs)}
        sh_cmd_head = r"set -e; cd %(d)s; " % form_dict
        sh_cmd_tail = (r"ls -d %(g)s 2>/dev/null || true; rm -rf %(g)s" %
                       form_dict)
        cwd = os.getcwd()
        for host in hosts + ["localhost"]:
            sdir = None
            try:
                if host == "localhost":
                    sdir = suite_engine_proc.get_suite_dir(suite_name)
                    app_runner.fs_util.chdir(sdir)
                    out = app_runner.popen.run_ok(sh_cmd_tail, shell=True)[0]
                else:
                    cmd = app_runner.popen.get_cmd("ssh", host,
                                                   sh_cmd_head + sh_cmd_tail)
                    out = app_runner.popen.run_ok(*cmd)[0]
            except RosePopenError as exc:
                app_runner.handle_event(exc)
            else:
                if sdir is None:
                    event = FileSystemEvent(FileSystemEvent.CHDIR,
                                            host + ":" + suite_dir_rel)
                    app_runner.handle_event(event)
                for line in sorted(out.splitlines()):
                    if host != "localhost":
                        line = host + ":" + line
                    event = FileSystemEvent(FileSystemEvent.DELETE, line)
                    app_runner.handle_event(event)
            finally:
                if sdir:
                    app_runner.fs_util.chdir(cwd)
        return

    def _get_conf(self, conf_tree, key, max_args=0):
        """Get a list of cycles from a configuration setting.

        key -- An option key in self.SECTION to locate the setting.
        max_args -- Maximum number of extra arguments for an item in the list.

        The value of the setting is expected to be split by shlex.split into a
        list of items. If max_args == 0, an item should be a string
        representing a cycle or an cycle offset. If max_args > 0, the cycle
        or cycle offset string can, optionally, have arguments. The arguments
        are delimited by colons ":".
        E.g.:

        prune-remote-logs-at=-6h -12h
        prune-datac-at=-6h:foo/* -12h:'bar/* baz/*' -1d
        prune-work-at=-6h:t1*:*.tar -12h:t1*: -12h:*.gz -1d

        If max_args == 0, return a list of cycles.
        If max_args > 0, return a list of (cycle, [arg, ...])

        """
        items_str = conf_tree.node.get_value([self.SECTION, key])
        if items_str is None:
            return []
        try:
            items_str = env_var_process(items_str)
        except UnboundEnvironmentVariableError as exc:
            raise ConfigValueError([self.SECTION, key], items_str, exc)
        items = []
        ref_time_point = os.getenv(
            RoseDateTimeOperator.TASK_CYCLE_TIME_MODE_ENV)
        date_time_oper = RoseDateTimeOperator(ref_time_point=ref_time_point)
        for item_str in shlex.split(items_str):
            args = item_str.split(":", max_args)
            offset = args.pop(0)
            cycle = offset
            if ref_time_point:
                try:
                    time_point, parse_format = date_time_oper.date_parse()
                    time_point = date_time_oper.date_shift(time_point, offset)
                    cycle = date_time_oper.date_format(
                        parse_format,
                        time_point)
                except ValueError:
                    pass
            if max_args:
                items.append((cycle, args))
            else:
                items.append(cycle)
        return items
